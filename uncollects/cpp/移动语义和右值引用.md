# 移动语义

移动语义在构造器中已经接触过，主要是为了解决拷贝语义性能损耗严重的问题。有了移动语义，一方面可以在部分场景下替代拷贝语义从而节省性能，另一方面也支持了`std::unique_ptr`这类只支持移动操作类型的创建。

了解了需求，也就知道后续的右值引用这种等等概念都是为了支持移动语义而产生的。

## 左值右值基本概念

C++的表达式有两个独立的属性，一个就是我们熟悉的类型，第二个是值的类别，即平常所说的左值右值。左值右值的概念是针对表达式的求值结果而言的。

值的类型在c++中是一个复杂的概念，实际上可以分成基本的三类：纯右值，速亡值和左值。其中速亡值和左值一起构成了泛左值的概念，而纯右值和速亡值一起构成了右值的概念。

左值有一个共同的特点，就是可以通过取地址符获取到内存地址。常见的泛左值有变量名，函数，类成员等。下面这几类左值可能会让人意外：

* 字符串字面值，如`"Hello, world"`，因为字符串字面值在c++中的格式实际是`const char *`,是一个固定字符数组，因此占有内存空间。
* 右值引用变量，如`T&& a`，变量`a`虽然类型是`右值引用`，但仍然有自己的内存空间，只是表示其资源可以被挪用。

纯右值最常见的就是内置类型字面值，比如`10`。下面这几类纯右值也比较意外：

* lambda表达式，如`[](int x){ return x*2; }`，lambda表达式是一个函数对象。
* 函数调用，如调用构造函数`S(1,2)`，这个表达式本身是纯右值的。

速亡值里面最常见的就是`std::move(x)`返回的右值引用对象，还有一类c++17开始的临时对象。比如下面的例子, `S(1)`就是一个临时物化的速亡值：

```cpp
    struct S {
        int m;
        S(int m): m(m) {}
        ~S() { std::cout << "~S() called" << std::endl; }
    }

    S(1).m;
```

对于左值表达式和纯右值表达式的区别下面这个递增递减运算符最能够看出区别：

```cpp
    int num = 5;
    std::cout << num++ << std::endl; // 后置递增运算符返回num递增前的值的副本，输出5
    num++ = 10;     // 编译会报错，后置递增运算符返回右值，无法作为赋值运算符左侧运算对象。

    num = 5;
    std::cout << ++num << std::endl; // 前置递增运算符递增，再返回num，输出6
    ++num = 10;     // 前置递增运算符返回左值，可以作为赋值运算符左侧运算对象
```

对象既可能是左值也可能是右值，当对象被用作左值时，使用的是对象的身份（在内存中的位置），而被用作右值时，使用的时对象的值（内容）。最简单的例子是在赋值运算时

```cpp
    int num, num2;
    num = 5;        // num作为左值使用
    num2 = num;     // num作为右值使用
```

参考[Value categories](https://en.cppreference.com/w/cpp/language/value_category)

## 左值引用和右值引用

左值引用就是普通引用，必须绑定在左值上，而右值引用是为了支持移动语义整出来的，具有完全相反的特性，必须绑定在右值上，包括纯右值和速亡值。

```cpp
    int num = 5;
    int&& num2 = 3; // 纯右值
    int&& num3 = std::move(num); // 速亡值
```

有一个角度比较有意思，右值引用延申了对象的生命周期。因为右值引用绑定一个将要消亡的对象上，从而使对象可以继续正常使用。

## std::move和std::forward

不要被`std::move`的名字所迷惑，它并不涉及资源的移动，`std::move`本质上是一个类型转换，将一个左值转换成一个右值引用。用来表示这个对象的资源可以被挪用，有一种鸠占鹊巢的感觉,这个过程中巢没有动，因为建巢费劲，只是鸟飞过来了。

```cpp
    S s1 = S(1, 2);
    S s2 = std::move(s1);
```

注意要实现资源移动，仅仅调用`std::move`是不够的，还要求类型实现了移动构造函数或移动赋值函数。否则尽管做了类型转换，最终还是调用了拷贝函数，并没有实现资源移动。

`std::forward`通常用在模板中，用于完美转发，`std::forward`的本质和`std::move`类似，是一个有条件的类型转换。无论传入是一个左值引用还是右值引用，都可以完美转发。

```cpp
    template<typename T>
    void fun(T&& param)
    {
        do(std::forward<T>(param));
    }
```

上面的`T&& param`也被称为万能引用，既可以接收左值引用，也可以接收右值引用。同理`auto&& param`也是一个通用引用，因为`auto`的类型推导机制和模板中的一致。

万能引用一般情况下非常有用，但要注意不要重载带万能引用的函数，因为非常容易误匹配，详见《Effective Modern C++》item26，如果确实需要重载，可以考虑使用标签分发实现，详见前书item27。

## 万能引用与引用折叠

万能引用其实不是c++的语言特性，只是为了与右值引用区分而取的名字，其背后的机制其实是引用折叠。

正常情况下C++不允许定义引用的引用。

```cpp
    int num = 1;
    int& &num2 = num; //编译报错
```

但在模板类型推导时是一个例外，允许出现引用的引用，这时就会发生引用折叠机制。引用折叠可以发生在左值引用和右值引用两两组合的场景下。除非两个都是右值引用产生右值引用，其他三类场景最终都是一个左值引用。

套用到万能引用场景时，当传入一个左值引用时，param的类型是左值引用，传入一个右值引用时，param的类型是右值引用。因此param具有了类型上的灵活性。
