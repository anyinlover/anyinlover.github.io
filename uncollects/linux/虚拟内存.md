# 虚拟内存

为什么要设计虚拟内存？

为了解决进程之间抢占甚至破坏物理内存资源的问题。

设计虚拟内存的目标：

1. 缓存：内存资源得以高效的利用
2. 内存管理：通过提供一致的地址空间来简化内存管理
3. 内存保护：保护进程的内存不被其他进程破坏

## 虚拟内存的工作原理

虚拟地址如何翻译到物理地址？

![](../../assets/image/2022-06-03-11-57-27.png)

通过CPU芯片上的的内存管理单元MMU，利用主存上的查询表动态翻译地址

虚拟地址是什么概念？

一般现代操作系统支持32位或64位的虚拟地址空间。虚拟地址空间一般是线性的，n位地址空间一般就有$2^n$个地址。也就是说32位地址空间有4G，而64位的地址空间达到了惊人的16E！

### 虚拟内存作为缓存的工具

虚拟内存被组织为一个存放在磁盘上的N个连续字节大小单元的数组。而主存作为其缓存使用。磁盘和主存之间通过固定大小的页交换。

由于磁盘速度比主存慢10w倍，DRAM缓存不命中和访问第一个字节的开销很大，因此一般虚拟页都会比较大。通过`getconf PAGESIZE`可以看到我的wsl上是4K。

通过常驻内存的页表可以找到虚拟页和物理页的映射关系，并用来触发三种行为。

![](../../assets/image/2022-06-05-21-56-33.png)

虚拟内存上的页有三种状态，对应也会触发三种行为：

已缓存的 -- 页命中
未缓存的 -- 缺页
未分配的 -- 分配页面

虚拟内存缓存的性能是局部性保证的，如果发生工作集大小超过了物理内存大小，就会出现持续换页的情况，这时候被称为抖动，可想而知性能会急剧下降。

### 虚拟内存作为内存管理的工具

操作系统为每个进程都维护了一个页表。通过这种方式可以极大的简化内存管理。

1. 简化链接。每个进程都可以拥有类似的内存格式。
2. 简化加载。当加载目标文件时，.text和.data仅仅分配了虚拟页，并被标记为未缓存的。实际执行时才会真正的把代码和数据加载进内存。
3. 简化共享。不同进程的虚拟页面可以映射到相同的物理页面，例如标准库函数和内核代码。
4. 简化内存分配。分配的连续的虚拟内存页面可以对应到不连续的物理内存中。

### 虚拟内存作为内存保护的工具

通过在PTE（页表条目）中拓展许可位，可以控制进程对虚拟内存页的访问权限。

![](../../assets/image/2022-06-06-21-03-49.png)

正常情况下，用户进程不能只读代码，也不能访问内核代码和数据，不能访问其他进程的私有内存。对于共享的虚拟内存也只有特殊条件下能实现。

当指令违反许可条件时，就会触发常见的“段错误segmentation fault”!

### 地址翻译

实际在地址翻译中还有很多细节问题需要处理。

地址翻译时间过长？

每次访问虚拟地址，都需要查阅一次PTE，需要几十到几百个周期。如果PTE在L1缓存上，则下降到1到2个周期。TLB试图消除这一类开销。其原理是在MMU内再做一层虚拟寻址的缓存。通过将虚拟页号VPN分组索引，可以很快的实现地址翻译。

![](../../assets/image/2022-06-06-21-29-11.png)

页表占据空间过大？

32位的地址空间，页面大小为4K，每个PTE占4字节，这种情况下一个页表就有4MB，这是不可接受的。常用的页表压缩方法是采用层次页表。

### Linux下的虚拟内存

Linux下的虚拟内存有一个固定的布局：

![](../../assets/image/2022-06-07-07-36-09.png)

里面有几点特殊的。

Linux会将一组连续的虚拟页面映射到一组连续的物理页面，大小就等于DRAM总量。这样内核可以方便的直接访问物理内存。

Linux会将虚拟内存组织为区域（段），通过维护区域来减少查找开销。

## 使用和管理虚拟内存

### 内存映射

通过将虚拟内存区域与磁盘对象关联起来用于初始化虚拟内存，被称为内存映射。存在两种类型：

1. 普通文件，文件会被分为页大小的片，每一片包含虚拟页的初始化内容。按需页面调度加载进内存。
2. 匿名文件，匿名文件是内核创建的全是0的留驻在物理内存中的区域，与磁盘无关。

如果被初始化的虚拟内存大小超过了物理内存大小，Linux有一个交换文件的概念，通过在磁盘上创建一个临时文件作为物理内存的补充，可以用来置换虚拟页面。

mmap函数可以用来创建用户级内存映射，对应的munmap用来删除虚拟内存区域

### 动态内存分配

动态内存分配器维护堆内存，其将堆看作不同大小的块的集合，维持其分配和空闲的状态。有两类分配器。

1. 显式分配器，要求应用显式释放堆内存，C中的malloc和free，C++中的new和delete。
2. 隐式分配器，也就是垃圾收集器，自动回收不再被使用的堆内存，比如java，python等。
