# 异常控制流

为什么需要异常控制流？

程序除了执行自己的正常逻辑之外，还需要对外部变化做出反应，这些都会使控制流发生突变。

1. 硬件层面：包到达网络适配器，磁盘数据已就绪
2. 操作系统层面：进程调度
3. 应用层：进程之间发送信号

异常控制流的目标

1. 实现应用程序可以调用操作系统服务
2. 实现复杂的进程管理
3. 实现并发机制
4. 实现软件异常

## 异常

异常是硬件和操作系统配合实现的控制流突变。其通过异常表调用异常处理程序，异常表的起始地址存放在异常表基址寄存器（CPU寄存器）中。

异常整体可分为四类：

![](../../assets/image/2022-06-19-08-35-32.png)

中断

包到达网络适配器，磁盘数据已就绪这类情况下，I/O设备会向处理器芯片一个引脚发信号，并将异常号放在系统总线上，标识引起中断的设备，这时候会出发中断。

![](../../assets/image/2022-06-19-08-35-56.png)

陷阱

陷阱是有意的异常，最重要的用途是系统调用。通过向内核请求服务，比如读文件write， 创建新进程fork，加载新程序execve，终止当前进程exit，处理器提供了"syscall n"的指令。之后会切换到内核模式运行。

![](../../assets/image/2022-06-19-08-36-15.png)

故障

当发生错误时，故障处理程序尝试修正错误，如果能够解决就返回当前指令继续执行，否则会返回到内核abort例程来终止应用程序。典型的故障例子就是缺页异常。

![](../../assets/image/2022-06-19-08-36-37.png)

终止

当不可恢复的致命错误发生时，通常是一些硬件错误，直接将控制返回到abort例程来终止应用程序。

![](../../assets/image/2022-06-19-08-37-07.png)

## 上下文切换

进程是一个执行中程序的实例，每个程序都运行在某个进程的上下文中。进程提供了两个关键抽象：

1. 一个独立的逻辑控制流：提供一个假象，程序独占着处理器。
2. 一个私有的地址空间：提供一个假象，程序独占着内存系统。

通过区分用户模式和内核模式，系统限制了一个应用程序可以执行的指令和访问的地址空间。

上下文切换是一种较高层次的异常控制流。上下文就是维持进程运行所需的状态，包括：

1. 通用目的寄存器
2. 浮点寄存器
3. 程序计数器
4. 用户栈
5. 状态寄存器
6. 内核栈
7. 内核数据结构：页表、进程表、文件表等

简单理解，当内核恢复一个被抢占的进程时，需要把相关状态都还原回来。

多种情况下都会发生上下文切换：

1. 系统调用：读写磁盘，或者是显式的sleep
2. 中断：定时器中断下，linux一般是10毫秒，内核会判定当前进程运行了足够长的时间，需要切换到新进程。

下面这个磁盘读取的例子非常生动的说明了上下文切换。

![](../../assets/image/2022-06-19-09-49-47.png)

进程控制

进程总是处于下面三种状态之一：

1. 运行：正在CPU上执行或者等待被调度执行
2. 停止：进程被挂起且不会被调度。当收到SIGSTOP，SIGTSTP，SIGTTIN或SIGTTOU信号时，进程停止，直到收到SIGCONT信号再次运行。
3. 终止：收到信号默认行为时终止进程；从主程序返回；调用exit函数



## 信号



## 非本地跳转
